# 数据结构



需要掌握的基础技能点

- 如何删除一个节点
- 如何插入一个节点：头插法和尾插法
- 如何交换节点



## 链表

单链表基本操作

```c++
1. 单链表
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}


2. 双链表
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```



### 需要掌握的基本操作

- 实现单链表、循环链表、双向链表，支持增删操作

- 实现单链表反转实

- 现两个有序的链表合并为一个有序链表

- 实现求链表的中间结点

  

### 常见题型

- 链表的倒置

- 删除链表中某个结点

- 合并两个排序链表

- 合并 k 个排序链表

- 排序两个无序链表

  

### 常用技巧

-  **使用dummy node**。dummy node就是在链表的head前加一个节点指向head，即dummy->head，可以理解成一个虚拟节点。多针对于单链表没有前向指针的问题，保证链表的head不会在删除操作中丢失。通常情况下，如果链表的head会发生变化，譬如删除或者被修改等，可以创建dummy node： ListNode dummy = new ListNode(0); dummy.next = head; 这样就使得操作head节点与操作其他节点没有区别。 

-  **双指针法**。对于寻找链表的某个特定位置，或者判断是否有环等问题时，可以用两个指针变量fast和slow: ListNode slow = head; ListNode fast = head; 以不同的速度遍历该链表，以找到目标位置。注意：在测试时，需要分别选取链表长度为奇数和偶数的test case，可以验证算法在一般情况下的正确性避免遗漏。 

-  **交换节点的处理**

  。如果需要交换两个节点的位置，譬如24题 `Swap Nodes in Pairs`,需要交换两个相邻位置的节点，对于这两个前驱节点，他们的next指针会受到影响，这两个节点本身也会受到影响，可以用以下步骤： 

  - 先交换两个前驱节点的next指针的值
  - 再交换这两个节点的next指针的值

   无论这两个节点的相对位置和绝对位置如何，以上的处理方式均可成立 

  

-  4.**同时操作两个链表的处理**。遇到这种题目，循环的条件一般可以用while（list1 && list2），当循环跳出来后，再处理剩下非空的链表，这相当于：边界情况特殊处理，常规情况常规处理。



### 常见边界情况

- 链表为空
- 链表中只有一个结点
- 链表中只包含两个结点
- 代码在处理头结点跟尾结点是否存在什么问题